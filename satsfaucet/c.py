captcha = "P1_eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJwYXNza2V5IjoiOVJacE14QXRBWlNCZC9uTzlXb2xoazlrcVl4MFNTdHB1Y3Y5MEF1T29wYkk5dTRDSzJRb210Skh5ZFNwWTc4YmhDZzI1bnV3alMwT2lNUk9mNVhhV1BqMXk3QUlOWUZZcFI1cVR5M2x5QlZ4dlRXUndra0hoUkZFZUJ2NWVUb0FtTHVaSVh3cXpCM05xNGUwVnZML1NQN1FXcmtURXNkQkFyVzZ5Sk1PY2hLdzRwN1BaeFlsVk16c1RIQWFXS1pndDVmaUt5bHhiUDZGT1k5UGUyU1d5ZW45WHhhaXRUVkpJbGNadTMxaTNUa2NDVUtKaXNEZjNHWldndUgzMUpzZUxXMm01SXNYR2ZGUnU1b2IyaUlFYVBZVXNMUXE3T0M4V0h6SGludU9oOFZ1aHJ6K1pnbms0TUNUaHRTclpiZCtGYitwMzVKN0pOc1RBTDNpSVlsOWtIdFl3d3FNaTJmbjhxd1U2cUllTHFkMlMyRE9iRm14Zk5GaGg5ZkJyU2xHN2dIOGNEb045eFREb0RLRjRqZ0s2TUk4NzlmMGp5TUNEUnNpVWNEWlpwSi94c21QZGZGbDdqc2ZadW43WHNxSXAvNFVUbG5RbmdFUjhpVFNQaW5nSmdrNEQwaWpxK3BxaitsVHJLWHBIK0Nobkc5OGdENGRyNFFkU1grU2Q4UFJqWmV0YUFLZEl5UDljNlZ0MkM3N1lzU1hFK0Zob2x4UUpaTWdWOEhzZzc3NVp5dTU0cFg4YStNRnpHQVhkM1pRa0Y0eHEyQUJmcU81V0RJMUV1bjVtbllQRWtSN1hFOHVTTkZTeWJocEkzak43cXNBOTZiYjVkM2hyT1FsVzd1dEUxemNjUTlYVTNFakt0WU1CZzAvTEh1RFJYa3NtV29ybmw1bW0yajJCMmQwYTlpSkloUHNCa1BpTFZrc1VKa21pNUZhZjBpRC9jT0I3N1picjBqRmZMV2ZqTVpWbGpZTFlyUDBDQ0I5VFQxWlVmUmJSLzF4NmdYVllOdzMreS9ieUxNVzZYS3FsQ0tkWDlXTm5RVDFzeHNwTXNUb2Nqa1hEOGFXd3MvQjA2YWkzUk5uMUFUbW41Yy9rQ0xIdHQ4ZXZVNG5QMlc0eTBkbGxGakw5VWdJakFsRm5tSHpLc29CSnVrdHNtbmg5R2c0OUM4MGJ2SktLaUpQaEU0bGt5RG4yZmQrY0trWFJNRlIrcHQycDdWNkVQTXU0UWs2S3Q5SVRSQ0VYOTcybEpnMXh1TDUvOTI5Y0FQdmt6ZDVBYU1XSGtSaHp4T2d1d2dkRkwvVEp4SHMybnZ2aXNYU1NqY2c3LzQxRWdZNjZCZXdGb3Nvay9DSTJ3N2lKTnRDUktwOFgvQ0g3MWp6UEFuQXpYSDhDZUt3Z0JjMkpJdjVyZXpBbDFxcGFrckJGR1h0RS92dU5ETmJoMW9SMFdnN2RPTmVRSnl1c2hvbGpFWWRBWC9iRW9UbU84SkI0T3Z1YkhjMTJKNnlzNGZ6RTVER3FjRk43Y3MxeVNlU2JVaG9yNWYwWVQ3OVErYUpaTTh5dXhQdVV1dDRKZjgwTUNzajJPc3MxRTZKOUd0QzkySXUzeG1uaVJTMDE1R2dYV0YzQ2pxZHpqUGJ6TGE4MGJEMk5xYWRESE4yZE82VEt6a0dCYjNxZDRlVVlYSDNWQWxENFhDY0dhVkZlYmhvbjkxNGpkdTRHMVRwM1pCUHBueHVnVEh2M1Jwc2ROemI0V0Y1Uzg5OXlTeFVCT1lsenlOVlJEcGpreFhFS05Dd3haWEJyNHJMUFFqd3EzUnpsWGJwaHpCelhmOHJIOFNuZVdnOFhUcDAzYzhEYzgzRGNrVmhlckNwN2dKVUIvOVpBazJzOVdtTDltT2ZqZ1Ezc3NsYWkvd3g5a3dCemJldXZhU0J0VllYSWJEMlBiS0NJWWJOZGFLendIZm00SzBNNW9udHZLYUpRWk9FTFRHOGxKRVhVNjBsMFNuQnYvV0NKSHhra2xvNTFaL3g0QmRaL0J5bmtRNGpDczRGeldJTFBITzIrU3AzZXJIWWVsTW5yNENkbnV0ZzRNdTlqdERkeXlYb2Z4ZHhvTTV6bEs2aVBtVW5aZjRoc0VINk5VTXBHWi9iRjBUeEY0Nlp1S0xTYTZvOGpYaHhjZjVFRHZvTWZ0eUt4Q1gxWm9Md0tERkZSTEFwaXBMa0Qxdlc4MWxGK3Yya0tzU0ZWT3BaSFZNQllnaERWQkVZbkxHVHk4NEpzakxxUVZQclB4TkYwcXJZWlZvZVB4YXpUcFlNWlY4czNqeGtiM0tRVFNMeHlPbzIyV3VNeGNrbkd4UUdNQWJobFVxaldUM1FpM2hrcndJUzE1c1JDeDVuODdYczBjOFBpZzAwMFA4b2wyNkE5ZUlvSTluc1JhWWt2MmEwNWIvb29aRFFOSE5iblZDOEtJckUyUzFWMTRveWNRZTAyM05YaDQ3U01nTkNXQkU4MVVneW1XbGo4dndWS2pBc1NaR3JNSGFMR3FnUnpQdytuS0dxYkx4UGlKTHFlYzFkQ3JOSjFJSjllcGxsa2hqU3ExSTRGTGU0Vi9lTUFlVEczTytDT05yZVVCbUdsM1NSRHVsaUE2Z2ZNOFBDMUZzWjBEZ0Q3L3kwNURFL3I5SVhmeHlGMnlBdzNvblM1QytwTUFMYUZDckJoUis5TTNmT2Q2bGJUQnVhdlFjSC92NFU5U1FGNXo4WFY4azM0SVBRcEhBdm95WU9vdHkycFJEVHZyZmpDL2locU5JaVFvbFVSWFF3cHllRU44dWRkdUpPWEZRVG12TEZyYjdGUzVyb1FNTzMvZUJaR3ExZWN1Yk82L3BlVTQ0eUNOS2EvVVJnamlNV1BLU2lDVnlPcVkzd2pkQk9JRzR6ODBjSCtPalFtb1N4L213Z212Y1haZTRFbEJHVXFMeVBraWlTL1ZXRzBJQi9OeVFZQ0pjeVdoeGg2WG1pdUh5SnN1ZUpqS1BHbExTOXdCeTR2VXhUMzFiT2NoL2RnREE9IiwiZXhwIjoxNzQzNTQzNjIzLCJzaGFyZF9pZCI6NTM1NzY1NTksImtyIjoiMTlmZjAxMmEiLCJwZCI6MH0.20F_cLSknfF3601XTcFFQJ4Liib-nphMbPNcwUy9UOI"
import requests
import time
import re
import random, string

BASE_URL = "https://api.mail.tm"
global authToken
authToken = None

# Funktion zur Erstellung einer temporären E-Mail
def create_temp_email():
    domains_response = requests.get(f"{BASE_URL}/domains").json()
    
    if not domains_response or "hydra:member" not in domains_response:
        print("Fehler beim Abrufen der Domains.")
        return None, None, None
    
    domain = domains_response["hydra:member"][0]["domain"]  # Erste verfügbare Domain nutzen
    user = "user"
    random_letters = ''.join(random.choices(string.ascii_lowercase, k=3))  # 3 zufällige Kleinbuchstaben
    new_user = user + random_letters
    email = f"{new_user}@{domain}"
    password = "SuperSicheresPasswort"
    
    payload = {"address": email, "password": password}
    response = requests.post(f"{BASE_URL}/accounts", json=payload)
    
    if response.status_code != 201:
        print("Fehler beim Erstellen der E-Mail:", response.json())
        return None, None, None
    
    print("Temporäre E-Mail erstellt:", email)
    return email, password, domain

# Funktion zur Anmeldung und Abruf des Tokens
def get_token(email, password):
    payload = {"address": email, "password": password}
    response = requests.post(f"{BASE_URL}/token", json=payload)
    
    if response.status_code != 200:
        print("Fehler beim Abrufen des Tokens:", response.json())
        return None
    
    token = response.json().get("token")
    print("Token erhalten:", token)
    return token

# Funktion zum Abrufen von E-Mails
def fetch_emails(token):
    headers = {"Authorization": f"Bearer {token}"}
    response = requests.get(f"{BASE_URL}/messages", headers=headers)
    
    if response.status_code != 200:
        print("Fehler beim Abrufen der E-Mails:", response.json())
        return []
    
    emails = response.json().get("hydra:member", [])
    return emails


from bs4 import BeautifulSoup

def extract_verification_link(email_content, email_html):
    # Falls HTML vorhanden ist, dieses bevorzugt analysieren
    content = email_html if email_html else email_content
    
    # HTML parsen
    soup = BeautifulSoup(content, "html.parser")
    
    # Alle Links aus der HTML extrahieren
    links = [a["href"] for a in soup.find_all("a", href=True)]
    
    # Den passenden Link für die Verifizierung suchen
    for link in links:
        if "https://api.satsfaucet.com/auth/verify-user-email" in link:
            return link
    
    return None



import requests
import time

API_KEY = "940b693a14a1110d444da2d03cb0ddd8"
email = "minewolf.gaer08@gmail.com"
password = "Frankreich7"
SITE_KEY = "2132b5cb-ab2c-40ca-83c0-b7cae5cd320a"
PAGE_URL = "https://www.satsfaucet.com/register"

import threading

def solve_hcaptcha(site_key, url):
    response = requests.post("http://2captcha.com/in.php", data={
        "key": API_KEY,
        "method": "hcaptcha",
        "sitekey": site_key,
        "pageurl": url,
        "json": 1
    }).json()

    if response["status"] != 1:
        print("Fehler beim Senden an 2Captcha:", response)
        return None

    captcha_id = response["request"]
    print(f"Löse CAPTCHA... (ID: {captcha_id})")

    solution = None  # Gemeinsame Variable für die Lösung
    lock = threading.Lock()  # Lock für sicheren Zugriff
    stop_event = threading.Event()  # Event zum Stoppen der Threads

    def check_captcha():
        nonlocal solution
        for _ in range(100):
            if stop_event.is_set():  # Falls bereits gelöst, sofort abbrechen
                return

            time.sleep(7)  # Prüfe alle 3 Sekunden
            result = requests.get(f"http://2captcha.com/res.php?key={API_KEY}&action=get&id={captcha_id}&json=1").json()
            
            if result["status"] == 1:
                with lock:  # Kritischen Bereich sichern
                    if solution is None:  # Nur die erste gefundene Lösung speichern
                        solution = result["request"]
                        print(f"CAPTCHA gelöst: {solution}")
                        stop_event.set()  # Andere Threads stoppen
                return  # Beende den Thread

    # Starte mehrere Threads
    threads = []
    for _ in range(3):  # 5 Threads starten
        t = threading.Thread(target=check_captcha)
        t.start()
        threads.append(t)

    # Warte auf alle Threads
    for t in threads:
        t.join()

    return solution  # Gibt nur die erste gültige Lösung zurück

def fucker(email, password):
    url = "https://api.satsfaucet.com/auth/register"
    
    
    
    payload = {"email": email, "password": password, "hCaptchaResponse": "P1_eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJwYXNza2V5IjoiOVJacE14QXRBWlNCZC9uTzlXb2xoazlrcVl4MFNTdHB1Y3Y5MEF1T29wYkk5dTRDSzJRb210Skh5ZFNwWTc4YmhDZzI1bnV3alMwT2lNUk9mNVhhV1BqMXk3QUlOWUZZcFI1cVR5M2x5QlZ4dlRXUndra0hoUkZFZUJ2NWVUb0FtTHVaSVh3cXpCM05xNGUwVnZML1NQN1FXcmtURXNkQkFyVzZ5Sk1PY2hLdzRwN1BaeFlsVk16c1RIQWFXS1pndDVmaUt5bHhiUDZGT1k5UGUyU1d5ZW45WHhhaXRUVkpJbGNadTMxaTNUa2NDVUtKaXNEZjNHWldndUgzMUpzZUxXMm01SXNYR2ZGUnU1b2IyaUlFYVBZVXNMUXE3T0M4V0h6SGludU9oOFZ1aHJ6K1pnbms0TUNUaHRTclpiZCtGYitwMzVKN0pOc1RBTDNpSVlsOWtIdFl3d3FNaTJmbjhxd1U2cUllTHFkMlMyRE9iRm14Zk5GaGg5ZkJyU2xHN2dIOGNEb045eFREb0RLRjRqZ0s2TUk4NzlmMGp5TUNEUnNpVWNEWlpwSi94c21QZGZGbDdqc2ZadW43WHNxSXAvNFVUbG5RbmdFUjhpVFNQaW5nSmdrNEQwaWpxK3BxaitsVHJLWHBIK0Nobkc5OGdENGRyNFFkU1grU2Q4UFJqWmV0YUFLZEl5UDljNlZ0MkM3N1lzU1hFK0Zob2x4UUpaTWdWOEhzZzc3NVp5dTU0cFg4YStNRnpHQVhkM1pRa0Y0eHEyQUJmcU81V0RJMUV1bjVtbllQRWtSN1hFOHVTTkZTeWJocEkzak43cXNBOTZiYjVkM2hyT1FsVzd1dEUxemNjUTlYVTNFakt0WU1CZzAvTEh1RFJYa3NtV29ybmw1bW0yajJCMmQwYTlpSkloUHNCa1BpTFZrc1VKa21pNUZhZjBpRC9jT0I3N1picjBqRmZMV2ZqTVpWbGpZTFlyUDBDQ0I5VFQxWlVmUmJSLzF4NmdYVllOdzMreS9ieUxNVzZYS3FsQ0tkWDlXTm5RVDFzeHNwTXNUb2Nqa1hEOGFXd3MvQjA2YWkzUk5uMUFUbW41Yy9rQ0xIdHQ4ZXZVNG5QMlc0eTBkbGxGakw5VWdJakFsRm5tSHpLc29CSnVrdHNtbmg5R2c0OUM4MGJ2SktLaUpQaEU0bGt5RG4yZmQrY0trWFJNRlIrcHQycDdWNkVQTXU0UWs2S3Q5SVRSQ0VYOTcybEpnMXh1TDUvOTI5Y0FQdmt6ZDVBYU1XSGtSaHp4T2d1d2dkRkwvVEp4SHMybnZ2aXNYU1NqY2c3LzQxRWdZNjZCZXdGb3Nvay9DSTJ3N2lKTnRDUktwOFgvQ0g3MWp6UEFuQXpYSDhDZUt3Z0JjMkpJdjVyZXpBbDFxcGFrckJGR1h0RS92dU5ETmJoMW9SMFdnN2RPTmVRSnl1c2hvbGpFWWRBWC9iRW9UbU84SkI0T3Z1YkhjMTJKNnlzNGZ6RTVER3FjRk43Y3MxeVNlU2JVaG9yNWYwWVQ3OVErYUpaTTh5dXhQdVV1dDRKZjgwTUNzajJPc3MxRTZKOUd0QzkySXUzeG1uaVJTMDE1R2dYV0YzQ2pxZHpqUGJ6TGE4MGJEMk5xYWRESE4yZE82VEt6a0dCYjNxZDRlVVlYSDNWQWxENFhDY0dhVkZlYmhvbjkxNGpkdTRHMVRwM1pCUHBueHVnVEh2M1Jwc2ROemI0V0Y1Uzg5OXlTeFVCT1lsenlOVlJEcGpreFhFS05Dd3haWEJyNHJMUFFqd3EzUnpsWGJwaHpCelhmOHJIOFNuZVdnOFhUcDAzYzhEYzgzRGNrVmhlckNwN2dKVUIvOVpBazJzOVdtTDltT2ZqZ1Ezc3NsYWkvd3g5a3dCemJldXZhU0J0VllYSWJEMlBiS0NJWWJOZGFLendIZm00SzBNNW9udHZLYUpRWk9FTFRHOGxKRVhVNjBsMFNuQnYvV0NKSHhra2xvNTFaL3g0QmRaL0J5bmtRNGpDczRGeldJTFBITzIrU3AzZXJIWWVsTW5yNENkbnV0ZzRNdTlqdERkeXlYb2Z4ZHhvTTV6bEs2aVBtVW5aZjRoc0VINk5VTXBHWi9iRjBUeEY0Nlp1S0xTYTZvOGpYaHhjZjVFRHZvTWZ0eUt4Q1gxWm9Md0tERkZSTEFwaXBMa0Qxdlc4MWxGK3Yya0tzU0ZWT3BaSFZNQllnaERWQkVZbkxHVHk4NEpzakxxUVZQclB4TkYwcXJZWlZvZVB4YXpUcFlNWlY4czNqeGtiM0tRVFNMeHlPbzIyV3VNeGNrbkd4UUdNQWJobFVxaldUM1FpM2hrcndJUzE1c1JDeDVuODdYczBjOFBpZzAwMFA4b2wyNkE5ZUlvSTluc1JhWWt2MmEwNWIvb29aRFFOSE5iblZDOEtJckUyUzFWMTRveWNRZTAyM05YaDQ3U01nTkNXQkU4MVVneW1XbGo4dndWS2pBc1NaR3JNSGFMR3FnUnpQdytuS0dxYkx4UGlKTHFlYzFkQ3JOSjFJSjllcGxsa2hqU3ExSTRGTGU0Vi9lTUFlVEczTytDT05yZVVCbUdsM1NSRHVsaUE2Z2ZNOFBDMUZzWjBEZ0Q3L3kwNURFL3I5SVhmeHlGMnlBdzNvblM1QytwTUFMYUZDckJoUis5TTNmT2Q2bGJUQnVhdlFjSC92NFU5U1FGNXo4WFY4azM0SVBRcEhBdm95WU9vdHkycFJEVHZyZmpDL2locU5JaVFvbFVSWFF3cHllRU44dWRkdUpPWEZRVG12TEZyYjdGUzVyb1FNTzMvZUJaR3ExZWN1Yk82L3BlVTQ0eUNOS2EvVVJnamlNV1BLU2lDVnlPcVkzd2pkQk9JRzR6ODBjSCtPalFtb1N4L213Z212Y1haZTRFbEJHVXFMeVBraWlTL1ZXRzBJQi9OeVFZQ0pjeVdoeGg2WG1pdUh5SnN1ZUpqS1BHbExTOXdCeTR2VXhUMzFiT2NoL2RnREE9IiwiZXhwIjoxNzQzNTQzNjIzLCJzaGFyZF9pZCI6NTM1NzY1NTksImtyIjoiMTlmZjAxMmEiLCJwZCI6MH0.20F_cLSknfF3601XTcFFQJ4Liib-nphMbPNcwUy9UOI", "refferal_code": "Intenz"}
    headers = {
        "accept": "application/json",
        "content-type": "application/json",
        "origin": "https://www.satsfaucet.com",
        "cookie": "satsfaucet-referrer=Intenz",
        "referer": "https://www.satsfaucet.com/register?r=Intenz",
    }

    response = requests.post(url, json=payload, headers=headers)
    print(response.json())


import os
try:
    import requests
except ModuleNotFoundError:
    os.system("pip install requests")
    import requests

email = "minewolf.gamer08@gmail.com "
password = "Frankreich7"
authToken = None

def getAuth(email, password="Frankreich7"):
    global authToken
    url = "https://api.satsfaucet.com/auth/login"
    payload = { "email": email, "password": password }
    headers = {
        "accept": "application/json",
        "content-type": "application/json",
        "origin": "https://www.satsfaucet.com",
        "referer": "https://www.satsfaucet.com/",
    }

    response = requests.post(url, json=payload, headers=headers)
    response_data = response.json()
    authToken = "Bearer " + response_data.get("token")
    print(authToken)
    return authToken

emailse = "https://api.satsfaucet.com/app/send-verification-email"


def emailsen():
    global authToken
    
    headers = {
        "accept": "application/json",
        "content-type": "application/json",
        "origin": "https://www.satsfaucet.com",
        "referer": "https://www.satsfaucet.com/",
        "Authorization": f"{authToken}"  # Token hier richtig setzen
    }

    payload = {}  # Falls ein Payload nötig ist, sonst einfach leer lassen

    response = requests.post(emailse, json=payload, headers=headers)
    response_data = response.json()
    print(f"EMAIL seNDER: {response_data}")



def getitems(authToken):
    headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": f"{authToken}"
        }
    url = "https://api.satsfaucet.com/app/backpack/get-items?sort=new&page=1&limit=32"
        
    response = requests.post(url, headers=headers)
    if response.status_code == 200:
        try:
            data = response.json()  # JSON-Antwort in ein Python-Objekt umwandeln
            
            if "items" in data and isinstance(data["items"], list):  # Prüfen, ob "items" vorhanden ist und eine Liste ist
                filtered_items = [item for item in data["items"] if item.get("rarity") == "legendary"]
                filtered_ids = [item["id"] for item in filtered_items]
                print(filtered_ids)
                return random.choice(filtered_ids)
            else:
                print("Fehler: Unerwartetes Datenformat", data)

        except requests.exceptions.JSONDecodeError:
            print("Fehler: Die API-Antwort ist kein gültiges JSON.", response.text)
    else:
        print(f"Fehler: {response.status_code}, {response.text}")

def sellitems(id, authToken):
    url = "https://api.satsfaucet.com/app/market/sell-item"
    payload = { "id": id, "price": 10 }
    headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": f"{authToken}"
        }
        
    response = requests.post(url, json=payload, headers=headers)
    print(response.json())

def buyitems(id, authToken):
    url = "https://api.satsfaucet.com/app/market/buy-item"
    payload = {"id":id}
    headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": f"{authToken}"
        }
        
    response = requests.post(url, json=payload, headers=headers)
    print(response.json())

import requests

def getahid(item_id, authToken):
    url = "https://api.satsfaucet.com/app/market/get-items-on-sale?page=1&limit=32&sort=new"
    headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
        "Authorization": f"{authToken}"
    }
    
    response = requests.post(url, headers=headers)
    
    if response.status_code == 200:
        data = response.json()
        for item in data.get("items", []):
            if item.get("id") == item_id:
                return item.get("auctionId")
    
    return None

def item(email):

    seller = getAuth(email, "Frankreich7")
    time.sleep(2)
    id = getitems(seller)
    time.sleep(2)
    sellitems(id, seller)
    buyer = getAuth("minewolf.gamer08@gmail.com", "Frankreich7")
    time.sleep(2)
    ahid = getahid(id, buyer)
    buyitems(ahid, buyer)

def gen():
    email, password, domain = create_temp_email()
    if email:
        token = get_token(email, password)
        if token:
            fucker(email, "Frankreich7")
            getAuth(email)
            emailsen()
            print("Warte auf E-Mails...")
            while True:
                time.sleep(10)  
                emails = fetch_emails(token)
                
                for emailo in emails:
                    email_id = emailo["id"]
                    response = requests.get(f"{BASE_URL}/messages/{email_id}", headers={"Authorization": f"Bearer {token}"})
                    if response.status_code == 200:
                        email_data = response.json()
                        email_content = email_data.get("text", "")
                        email_html = email_data.get("html", "")  # HTML-Inhalt abrufen
                        if isinstance(email_html, list):
                            email_html = " ".join(email_html)  # Liste in String umwandeln
                        if isinstance(email_content, list):
                            email_content = " ".join(email_content)

                        
                        verification_link = extract_verification_link(email_content, email_html)
                        if verification_link:
                            import webbrowser

                            response = requests.get(verification_link)

                            if response.status_code == 200:
                                print("E-Mail erfolgreich verifiziert!")

                            with open("accs.txt", "a") as file:
                                file.write(f"{email}:Frankreich7\n")
                            
                            time.sleep(1)
                            item(email)
                            
                            gen()
                            

                        else:
                            print("Kein Bestätigungslink gefunden.")

gen()